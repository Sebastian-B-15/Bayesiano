0.8 * 0.15 + 0.2 *0.85
0.8 * 0.15/0.29
0.93 * 0.00148 + 0.01 * 0.99852
0.93*0.00148/0.0113616
0.93 * 0.12 + 0.01 * 0.88
0.93*0.12
0.93*0.12+0.01*0.88
0.1116/0.1204
0.93^2
0.93*0.93+0.01*0.07
0.865/0.93*0.93+0.01*0.07
0.865/(0.93*0.93+0.01*0.07)
0.07*0.93/(0.07*0.93 + 0.99*0.07)
qnorm(0.5)
qnorm(0.8)
qnorm(0.2)
0.45*0.3
0.135^2
0.3/0.7
0.135^2/0.3
10/7 *0.06075
1 - 0.08678571
10/7 *0.06075 * 10/7
0.9132143/0.1239796
7.365843*3/7
reticulate::repl_python()
reticulate::repl_python()
from scipy.optimize import fsolve
import math
def equations(p):
a, b = p
return ((a*b)/((a+b)**2 * (a+b+1)) - 0.018225, a/(a+b) - 0.3)
a, b =  fsolve(equations, (1, 1))
print equations((a, b))
from scipy.optimize import fsolve
import math
def equations(p):
a, b = p
return ((a*b)/((a+b)**2 * (a+b+1)) - 0.018225, a/(a+b) - 0.3)
a, b =  fsolve(equations, (1, 1))
print equations((a, b))
print("hola")
from scipy.optimize import fsolve
import math
def equations(p):
a, b = p
return ((a*b)/((a+b)**2 * (a+b+1)) - 0.018225, a/(a+b) - 0.3)
a, b =  fsolve(equations, (1, 1))
print equations((a, b))
import fsolve
import math
def equations(p):
a, b = p
return ((a*b)/((a+b)**2 * (a+b+1)) - 0.018225, a/(a+b) - 0.3)
a, b =  fsolve(equations, (1, 1))
print equations((a, b))
from scipy.optimize import fsolve
import math
import numpy as np
def equations(p):
a, b = p
return ((a*b)/((a+b)**2 * (a+b+1)) - 0.018225, a/(a+b) - 0.3)
a, b =  fsolve(equations, (1, 1))
print equations((a, b))
from scipy.optimize import fsolve
import math
import numpy as np
def equations(v):
a = v[0]
b = v[1]
F = np.empty(2)
F[0] = (x*y)/((x+y)**2 * (x+y+1)) - 0.018225
F[1] = x/(x+y) - 0.3
return F
vGuess = np.array([3,-3])
z = fsolve(equations, vGuess)
print equations(z)
sudo apt-get install python-scipy
pip install scipy
sudo apt-get install python-scipy
pip install scipy
from scipy.optimize import fsolve
import math
import numpy as np
def equations(v):
a = v[0]
b = v[1]
F = np.empty(2)
F[0] = (x*y)/((x+y)**2 * (x+y+1)) - 0.018225
F[1] = x/(x+y) - 0.3
return F
vGuess = np.array([3,-3])
z = fsolve(equations, vGuess)
print equations(z)
quit
library(TeachingDemos)
#| warning: false
library(TeachingDemos)
q_lower <- qbeta(0.1/2, alpha_post, beta_post)
alpha_post = 14.2
beta_post = 23.4
(intervalo <- hpd(qbeta, shape1 = alpha_post, shape2 = beta_post, conf = 0.9))
#El primer argumento es la función inversa a la FDA
#Los demás argumentos son los parámetros de la FDA y conf= es la credibilidad
q_lower <- qbeta(0.1/2, alpha_post, beta_post)
q_upper <- qbeta(0.9/2, alpha_post, beta_post)
c(q_lower, q_upper)
alpha_post = 14.2
beta_post = 23.4
(intervalo <- hpd(qbeta, shape1 = alpha_post, shape2 = beta_post, conf = 0.9))
#El primer argumento es la función inversa a la FDA
#Los demás argumentos son los parámetros de la FDA y conf= es la credibilidad
q_lower <- qbeta(0.05, alpha_post, beta_post)
q_upper <- qbeta(0.95, alpha_post, beta_post)
c(q_lower, q_upper)
y <- c(118, 74, 44, 24, 29, 22, 20, 14, 20, 15, 12, 14, 6, 12, 6,
9, 9, 6, 10, 10, 11, 5, 3, 3)
length(y)
ponderacion <- 1:24
n <- sum(y*ponderacion)
alpha <- 1
beta <- 1
alpha_1 <- sum(y) + alpha
beta_1 <- n + beta
hpd(qgamma, shape = alpha_1, scale = 1/beta_1, conf = 0.95)
y <- c(118, 74, 44, 24, 29, 22, 20, 14, 20, 15, 12, 14, 6, 12, 6,
9, 9, 6, 10, 10, 11, 5, 3, 3)
length(y)
ponderacion <- 1:24
n <- sum(y*ponderacion)
alpha <- 1
beta <- 1
alpha_1 <- sum(y) + alpha
beta_1 <- n + beta
hpd(qgamma, shape = alpha_1, rate = beta_1, conf = 0.95)
y <- c(118, 74, 44, 24, 29, 22, 20, 14, 20, 15, 12, 14, 6, 12, 6,
9, 9, 6, 10, 10, 11, 5, 3, 3)
length(y)
ponderacion <- 1:24
n <- sum(y*ponderacion)
alpha <- 1
beta <- 1
alpha_1 <- sum(y) + alpha
beta_1 <- n + beta
hpd(qgamma, shape = alpha_1, scale = 1/beta_1, conf = 0.95)
x <- NULL
for (i in 1:length(registro)) {
x <- c(x, rep(i, registro[i]))
}
registro <- c(118, 74, 44, 24, 29, 22, 20, 14, 20, 15, 12, 14, 6, 12, 6,
9, 9, 6, 10, 10, 11, 5, 3, 3)
x <- NULL
for (i in 1:length(registro)) {
x <- c(x, rep(i, registro[i]))
}
table(x) # Deberíamos obtener el registro
suma_x <- sum(x)
n <- length(x)
install.packages("nleqslv")
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]x[2]/((x[1] + x[2])^2 + (x[1] + x[2] + 1)) - 0.018225
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]*x[2]/((x[1] + x[2])^2 + (x[1] + x[2] + 1)) - 0.018225
return(c(ec1, ec2))
}
guess <- c(10,10) #Valor inicial para las iteraciones
nleqslv(guess, eqs)
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]*x[2]/((x[1] + x[2])^2 + (x[1] + x[2] + 1)) - 0.018225
return(c(ec1, ec2))
}
guess <- c(10,10) #Valor inicial para las iteraciones
nleqslv(guess, eqs)
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]*x[2]/((x[1] + x[2])^2 + (x[1] + x[2] + 1)) - 0.018225
return(c(ec1, ec2))
}
guess <- c(10,10) #Valor inicial para las iteraciones
nleqslv(guess, ecuaciones)
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]*x[2]/((x[1] + x[2])^2 + (x[1] + x[2] + 1)) - 0.018225
return(c(ec1, ec2))
}
guess <- c(7,3) #Valor inicial para las iteraciones
nleqslv(guess, ecuaciones)
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]*x[2]/((x[1] + x[2])^2 + (x[1] + x[2] + 1)) - 0.018225
return(c(ec1, ec2))
}
guess <- c(7,3) #Valor inicial para las iteraciones
nleqslv(guess, ecuaciones)
ecuaciones(c(nleqslv(guess, ecuaciones)$x))
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]*x[2]/((x[1] + x[2])^2 * (x[1] + x[2] + 1)) - 0.018225
return(c(ec1, ec2))
}
guess <- c(7,3) #Valor inicial para las iteraciones
nleqslv(guess, ecuaciones)
ecuaciones(c(nleqslv(guess, ecuaciones)$x))
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]*x[2]/((x[1] + x[2])^2 * (x[1] + x[2] + 1)) - 0.018225
return(c(ec1, ec2))
}
guess <- c(10,10) #Valor inicial para las iteraciones
nleqslv(guess, ecuaciones)
ecuaciones(c(nleqslv(guess, ecuaciones)$x))
library(nleqslv) #cargamos la librería respectiva nleqslv por ejemplo
ecuaciones <- function(x){
ec1 <- x[1]/(x[1] + x[2]) - 0.3 #esta es la función de la primera ecuación igualada a 0: f(x,y) = 0
ec2 <- x[1]*x[2]/((x[1] + x[2])^2 * (x[1] + x[2] + 1)) - 0.018225
return(c(ec1, ec2))
}
guess <- c(10,10) #Valor inicial para las iteraciones
nleqslv(guess, ecuaciones, critval = 10^(-10)) #El valor indicado por $x es cercano al que estimamos
mean(x)
qgamma(c(0.025, 0.975), shape = alpha_1, rate = beta_1)
suma_x <- sum(x)
n <- length(x)
alpha <- 1
beta <- 1
alpha_1 <- suma_x + alpha
beta_1 <- n + beta
qgamma(c(0.025, 0.975), shape = alpha_1, rate = beta_1)
